import { GenerateReadOnly, AllReadOnlys } from "./App";
var generated = false;
export function GenerateReadOnlys() {
  if (generated) return;
  generated = true;
  GenerateReadOnly("array.bc", "metamethod getindex<T>(Array<T> this, int i) -> T{\n    return *(this.Data+i%this.Length);\n}\nmetamethod setindex<T>(Array<T> this, int i, T v){\n    *(this.Data+i%this.Length) = v;\n}\nmetamethod ptrindex<T>(Array<T> this, int i) -> @T{\n    return this.Data+i%this.Length;\n}\n\nclass Array<T> {\n    new(int l){\n        this.Data = alloc(l);\n        this.Length = l;\n    }\n    int Length;\n    @T Data;\n    virtual function ReplaceV(func(T)->T over){\n        int i = 0;\n        while(i < this.Length){\n            this[i] = over(this[i]);\n            i++;\n        }\n    }\n    virtual function ReplaceK(func(int)->T over){\n        int i = 0; \n        while(i < this.Length){\n            this[i] = over(i);\n            i++;\n        }\n    }\n    virtual function ReplaceKV(func(int,T)->T over){\n        int i = 0;\n        while(i < this.Length){\n            this[i] = over(i, this[i]);\n            i++;\n        }\n    }\n}");
  GenerateReadOnly("extmacros.bc", "macro ( (assignable) (/\\/%|<<|>>|<=|>=|==|!=|&&|\\|\\||[*^\\/%+<>&~|-]/) \"=\" (expression) ) { $1 = $1 $2 $3 }\nmacro ( 'for' \"(\" (expression?) \";\" (expression?) \";\" (expression?) \")\" (expression) ) {\n    {\n        $1;\n        while($2){\n            $4;\n            $3;\n        }\n    }\n}\nmacro ( 'new' type '[]' '{' '}' ){{}}\nmacro ( 'new' (type) '[]' '{'  ','? (expression) ((',' expression)*) '}' ) {{\n    $1 a = $2;\n    new $1[]{$3};\n    &a;\n}}\nmacro ( 'new' (type) '[' (number) ']' ){ (reserve $2 -> @$1) };\n");
  GenerateReadOnly("float.bc", "include stringify.bc;\nmetamethod get_sign(float this) -> int (this -> int) / 0x80000000;\nmetamethod get_exponent(float this) -> int ((this -> int) / 0x800000) % 0x100;\nmetamethod get_mantissa(float this) -> int (this -> int) % 0x800000;\n\nconst int bias = 127+23;\nmetamethod get_integer(float this) -> int {\n    int mantissa = this.mantissa + 0x800000;\n    int exponent = this.exponent;\n    if(exponent == 0xFF){ // MAXINT, Can be NaN but hecc NaN\n        return  if (this.sign)\n                    0x80000000\n                else\n                    0x7fffffff;\n    }\n    while(exponent < bias){\n        exponent ++;\n        mantissa = mantissa / 2;\n    }\n    while(exponent > bias){\n        exponent --;\n        mantissa = mantissa * 2;\n    }\n    if(this.sign == 1){\n        mantissa = 0-mantissa;\n    }\n    return mantissa;\n}\n\nmetamethod get_float(int this) -> float {\n    int sign = 0;\n    if (this > 0x7fffffff) {\n        sign = 1;\n        this = 0-this;\n    }\n    int mantissa = this;\n    int exponent = bias;\n    while(mantissa >= 0x1000000){\n        exponent ++;\n        mantissa = mantissa / 2;\n    }\n    while(mantissa < 0x800000){\n        exponent --;\n        mantissa = mantissa * 2;\n    }\n    return ((sign * 0x80000000) + (exponent * 0x800000) + (mantissa % 0x800000) -> float);\n}\n\nmetamethod unm(float this) -> float {\n    return this.withSign(1 - this.sign);\n}\n\nabstract class float {\n    static const float one = 0x3F800000;\n    static const float zero = 0;\n    static const float ten = 0x41200000;\n\n    static function make(int sign, int exponent, int mantissa) -> float\n        ((sign * 0x80000000) + (exponent * 0x800000) + mantissa -> float);\n    virtual function withSign(int sign) -> float\n        float.make(sign, this.exponent, this.mantissa);\n    virtual function withExponent(int exponent) -> float\n        float.make(this.sign, exponent, this.mantissa);\n    virtual function withMantissa(int mantissa) -> float\n        float.make(this.sign, this.exponent, mantissa);\n    static function _sub(float this, float other) -> float {\n        if(this.sign != other.sign){\n            return float._add(this,-other);\n        }\n        if((this -> int) == 0)\n            return -other;\n        if((other -> int) == 0)\n            return this;\n        // Get both mantissas with their implied 1\n        int mantissaA = this.mantissa + 0x800000;\n        int mantissaB = other.mantissa + 0x800000;\n        // Get both exponents\n        int exponentA = this.exponent;\n        int exponentB = other.exponent;\n        // Shift left the smaller mantissa to match the larger one\n        // We don't actually have bitshift, so we have to manually multiply\n        int sign = this.sign;\n        while(exponentA < exponentB){\n            exponentA ++;\n            mantissaA = mantissaA / 2;\n        }\n        while(exponentB < exponentA){\n            exponentB ++;\n            mantissaB = mantissaB / 2;\n        }\n        if (mantissaB > mantissaA) {\n            mantissaA, mantissaB = (mantissaB, mantissaA -> int, int);\n            sign = 1 - sign;\n        }\n        // Subtract the mantissas\n        int mantissaC = mantissaA - mantissaB;\n        // Normalize the mantissa\n        while(mantissaC < 0x800000){\n            exponentA --;\n            mantissaC = mantissaC * 2;\n        }\n        // Return the result\n        return float.make(sign, exponentA, mantissaC % 0x800000);\n    }\n    static function _add(float this, float other) -> float {\n        if((this -> int) == 0)\n            return other;\n        if((other -> int) == 0)\n            return this;\n        if(this.sign != other.sign){\n            return float._sub(this,-other);\n        }\n        // Get both mantissas with their implied 1\n        int mantissaA = this.mantissa + 0x800000;\n        int mantissaB = other.mantissa + 0x800000;\n        // Get both exponents\n        int exponentA = this.exponent;\n        int exponentB = other.exponent;\n        // Shift left the smaller mantissa to match the larger one\n        // We don't actually have bitshift, so we have to manually multiply\n        while(exponentA < exponentB){\n            exponentA ++;\n            mantissaA = mantissaA / 2;\n        }\n        while(exponentB < exponentA){\n            exponentB ++;\n            mantissaB = mantissaB / 2;\n        }\n        // Add the mantissas\n        int mantissaC = mantissaA + mantissaB;\n        // Normalize the mantissa\n        while(mantissaC >= 0x1000000){\n            exponentA ++;\n            mantissaC = mantissaC / 2;\n        }\n        // Return the result\n        return float.make(this.sign, exponentA, mantissaC % 0x800000);\n    }\n    static function _mul(float this, float other) -> float {\n        if((this -> int) == 0)\n            return (0 -> float);\n        if((other -> int) == 0)\n            return (0 -> float);\n        // Get both mantissas with their implied 1\n        int mantissaA = this.mantissa + 0x800000;\n        int mantissaB = other.mantissa + 0x800000;\n        // Get both exponents\n        int exponentA = this.exponent;\n        int exponentB = other.exponent;\n        int exponentC = (exponentA + exponentB) - 134;\n        // Multiply the mantissas\n        int mantissaC = (mantissaA / 0x100) * (mantissaB / 0x100);\n        // Normalize the mantissa\n        while(mantissaC >= 0x1000000){\n            exponentC ++;\n            mantissaC = mantissaC / 2;\n        }\n        // Return the result\n        return float.make(this.sign + other.sign, exponentC, mantissaC % 0x800000);\n    }\n    static function _div(float this, float other) -> float {\n        if((this -> int) == 0)\n            return (0 -> float);\n        if((other -> int) == 0)\n            return (0x7fc00000 -> float);\n        // Floating point Division\n        // Apparently this is just like fancy fixed-point division\n        int mantissaA = this.mantissa + 0x800000;\n        int mantissaB = other.mantissa + 0x800000;\n        int exponentA = this.exponent;\n        int exponentB = other.exponent;\n        \n        int mantissaC = 0;\n        int div, int rem = (mantissaA * 0x100) /% mantissaB;\n        mantissaC = div * 0x8000;\n        div, rem = (rem * 0x100) /% mantissaB;\n        mantissaC = mantissaC + (div * 0x80);\n        div, rem = (rem * 0x100) /% mantissaB;\n        mantissaC = mantissaC + (div / 2);\n        int exponentC = (exponentA - exponentB) + 127;\n\n        if(mantissaC == 0){\n            return (0 -> float);\n        }\n        while(mantissaC < 0x800000){\n            exponentC --;\n            mantissaC = mantissaC * 2;\n        }\n        return float.make(this.sign + other.sign, exponentC, mantissaC % 0x800000);\n    }\n    static function _pow(float this, int base) -> float {\n        if (base == 0) {\n            return (0x3F800000 -> float);\n        }\n        if ((this -> int) == 0) {\n            return (0x0 -> float);\n        }\n        // Use simple binary exponentiation\n        float result = (0x3F800000 -> float);\n        while (base > 0) {\n            if (base % 2 == 1) {\n                result = float._mul(result, this);\n            }\n            this = float._mul(this, this);\n            base = base / 2;\n        }\n        return result;\n    }\n    static function _mod(float this, float other) -> float {\n        if((this -> int) == 0)\n            return (0 -> float);\n        if((other -> int) == 0)\n            return (0x7fc00000 -> float);\n        // Get both their mantissas\n        int mantissaA = this.mantissa + 0x800000;\n        int mantissaB = other.mantissa + 0x800000;\n        // And their exponents\n        int exponentA = this.exponent;\n        int exponentB = other.exponent;\n        // If A has a smaller exponant than B, return A (Because it will never be bigger than B)\n        if(exponentA < exponentB){\n            return this;\n        }\n        // Shift A until it has the same exponant as B\n        while(exponentA > exponentB){\n            exponentA --;\n            mantissaA = mantissaA * 2;\n        }\n        // Perform the modulo on the mantissas\n        int mantissaC = mantissaA % mantissaB;\n        if(mantissaC == 0){\n            return (0 -> float);\n        }\n        // Normalize the mantissa\n        while(mantissaC < 0x800000){\n            exponentA --;\n            mantissaC = mantissaC * 2;\n        }\n        // Return the result\n        return float.make(this.sign, exponentA, mantissaC % 0x800000);\n    }\n}\n\nmetamethod sub(float this, float other) -> float\n    float._sub(this, other);\n\nmetamethod add(float this, float other) -> float\n    float._add(this, other);\n\nmetamethod mul(float this, float other) -> float\n    float._mul(this, other);\n\nmetamethod div(float this, float other) -> float\n    float._div(this, other);\n\nmetamethod pow(float this, int other) -> float\n    float._pow(this, other);\n\nmetamethod mod(float this, float other) -> float\n    float._mod(this, other);\n\nmetamethod lt(float a, float b) -> int{\n    if(a.sign != b.sign){\n        return a.sign;\n    }\n    if(a.exponent != b.exponent){\n        return if (a.sign)\n                    a.exponent > b.exponent\n                else\n                    a.exponent < b.exponent;\n    }\n    return if (a.sign)\n                a.mantissa > b.mantissa\n            else\n                a.mantissa < b.mantissa;\n}\nmetamethod le(float a, float b) -> int{\n    if(a.sign != b.sign){\n        return a.sign;\n    }\n    if(a.exponent != b.exponent){\n        return if (a.sign)\n                    a.exponent > b.exponent\n                else\n                    a.exponent < b.exponent;\n    }\n    return if (a.sign)\n                a.mantissa >= b.mantissa\n            else\n                a.mantissa <= b.mantissa;\n}\nmetamethod gt(float a, float b) -> int{\n    if(a.sign != b.sign){\n        return b.sign;\n    }\n    if(a.exponent != b.exponent){\n        return if (a.sign)\n                    a.exponent < b.exponent\n                else\n                    a.exponent > b.exponent;\n    }\n    return if (a.sign)\n                a.mantissa < b.mantissa\n            else\n                a.mantissa > b.mantissa;\n}\nmetamethod ge(float a, float b) -> int{\n    if(a.sign != b.sign){\n        return b.sign;\n    }\n    if(a.exponent != b.exponent){\n        return if (a.sign)\n                    a.exponent < b.exponent\n                else\n                    a.exponent > b.exponent;\n    }\n    return if (a.sign)\n                a.mantissa <= b.mantissa\n            else\n                a.mantissa >= b.mantissa;\n}\n\nfunction almost_equal(int mantA, int mantB) -> int {\n    int diff = mantA - mantB;\n    return (diff < 0x100) || (diff > 0xFFFFFF00);\n} \n\nmetamethod eq(float a, float b) -> int\n    return (a.sign == b.sign) && (a.exponent == b.exponent) && almost_equal(a.mantissa, b.mantissa);\nmetamethod ne(float a, float b) -> int\n    return (a.sign != b.sign) || (a.exponent != b.exponent) || !almost_equal(a.mantissa, b.mantissa);\n\nmacro ( '__divide_float' (number) ',' (number) ) { const {\n    const int A = $1;\n    const int other = $2;\n    if(A == 0)\n        0\n    else if(other == 0)\n        0x7fc00000\n    else {\n        const int mantissaA = (A%0x800000) + 0x800000;\n        const int mantissaB = (other%0x800000) + 0x800000;\n        const int exponentA = (A/0x800000)%0x100;\n        const int exponentB = (other/0x800000)%0x100; \n        \n        const int mantissaC = 0;\n        const int div = (mantissaA * 0x100) / mantissaB;\n        const int rem = (mantissaA * 0x100) % mantissaB;\n        const mantissaC = div * 0x8000; \n        const div = (rem * 0x100) / mantissaB;\n        const rem = (rem * 0x100) % mantissaB;\n        const mantissaC = mantissaC + (div * 0x80);\n        const div = (rem * 0x100) / mantissaB;\n        const rem = (rem * 0x100) % mantissaB;\n        const mantissaC = mantissaC + (div / 2);\n        const int exponentC = (exponentA - exponentB) + 127;\n    \n        const if(mantissaC == 0){\n            0;\n        }else{\n            const while(mantissaC < 0x800000){\n                exponentC = exponentC - 1;\n                mantissaC = mantissaC * 2;\n            }\n            const ((((A/0x80000000) + (other/0x80000000))%2)*0x80000000) + ((exponentC%0x100) * 0x800000) + (mantissaC % 0x800000);\n        }\n    }\n}}\n\nmacro ( '__number_to_float' (number) ) { const {\n        const int A = $1;\n        const int sign = 0;\n        const if (A > 0x7fffffff) {\n            sign = 1;\n            A = 0-A; \n        }else {0}\n        const int mantissa = A;\n        const int exponent = bias;\n        const while(mantissa >= 0x1000000){\n            exponent = exponent + 1;\n            mantissa = mantissa / 2;\n        };\n        const while(mantissa < 0x800000){\n            exponent = exponent - 1;\n            mantissa = mantissa * 2; \n        };\n        const (sign * 0x80000000) + (exponent * 0x800000) + (mantissa % 0x800000); \n} }\n\nmacro ( '__count_digits' /\\d/ (/\\d+/)) {1+__count_digits $1}\nmacro ( '__count_digits' /\\d/) {1}\n\nmacro ( '__tenth_power' (number) ) {const {\n    const int t = 1;\n    const int i = 1+$1;\n    const while(i=i-1)t = t * 10;\n    t;\n}} \n\nmacro ( (number) '.' (/\\d+/) 'f' ) { (const {\n    const int divisor = (__tenth_power __count_digits $2);\n    const int numerator = $1;\n    numerator = (numerator * divisor) + $2;\n    (__divide_float (__number_to_float numerator) , (__number_to_float divisor));\n} -> float) }\n\nfunction stringifyFloat(float this, func(int) iter){\n    int integer = this.integer;\n    intToString(integer, iter);\n    this = this - integer.float;\n    if(this == float.zero)return;\n    iter('.');\n    int i = 6;\n    while(this != float.zero && --i){\n        this = this * float.ten;\n        integer = this.integer;\n        iter(integer+'0');\n        this = this - integer.float;\n    }\n}\nmetamethod cast(float this) -> stringified stringified.from(this, stringifyFloat);");
  GenerateReadOnly("int.bc", "metamethod pow(int _a, int _b) -> int {\n    if(!_b)\n        return 1;\n    if(_b == 1)\n        return _a;\n    int _result = 1;\n    while(_b > 0){\n        if(!(_b%2)){\n            _b = _b / 2;\n            _a = _a * _a;\n        }else{\n            _b = _b - 1\n            _result = _result * _a;\n            _b = _b / 2;\n            _a = _a * _a\n        }\n    }\n    return _result;\n}\nmetamethod bshl(int _a, int _b) -> int {\n    return _a * (2 ^ _b);\n}\nmetamethod bshr(int _a, int _b) -> int {\n    return _a / (2 ^ _b);\n}\nmetamethod band(int _a, int _b) -> int {\n    int _o = 0;\n    int _i = 1;\n    while (_i){\n        _o = _o + ((_a%2)*(_b%2))*_i;\n        _i = _i * 2;\n        _a = _a / 2;\n        _b = _b / 2;\n    }\n    return _o;\n}\nmetamethod bor(int _a, int _b) -> int {\n    int _o = 0;\n    int _i = 1;\n    while (_i){\n        _o = _o + !(!(_a%2)*!(_b%2))*_i;\n        _i = _i * 2;\n        _a = _a / 2;\n        _b = _b / 2;\n    }\n    return _o;\n}\nmetamethod bxor(int _a, int _b) -> int {\n    int _o = 0;\n    int _i = 1;\n    while (_i){\n        _o = _o + (_a%2!=_b%2)*_i;\n        _i = _i * 2;\n        _a = _a / 2;\n        _b = _b / 2;\n    }\n    return _o;\n}\n\n// int can cast to everything implicitely, via modulo\n// Whilst int acts as an insigned value generally, we allow it to be cast to signed values destructively.\nmetamethod cast(int _i) -> u32 (_i -> u32);\nmetamethod cast(int _i) -> s32 (_i -> s32);\n// Likewise, everything can cast to int implicitly\nmetamethod cast(u32 _i) -> int (_i -> int);\nmetamethod cast(s32 _i) -> int (_i -> int);\n// u32s can cast to u16 and u8, and so on (Including in reverse)\nmetamethod cast(u32 _i) -> u16 ((_i -> int) % 0x10000 -> u16);\nmetamethod cast(u32 _i) -> u8  ((_i -> int) % 0x100 -> u8);\nmetamethod cast(u16 _i) -> u32 ((_i -> int) -> u32);\nmetamethod cast(u16 _i) -> u8  ((_i -> int) % 0x100 -> u8);\nmetamethod cast(u8  _i) -> u32 ((_i -> int) -> u32);\nmetamethod cast(u8  _i) -> u16 ((_i -> int) -> u16);\n// Same with signed values, although special attention must be paid to the sign bit\n// To go from s32, we take the value % 0x8000, which leaves 15 bits of data and the sign bit\n// We transfer the sign bit by adding (_i / 0x80000000) * 0x8000, Same for the other bits and values\nmetamethod cast(s32 _i) -> s16 (\n    ((_i -> int) % 0x8000) + ((_i -> int) / 0x80000000) * 0x8000 -> s16\n);\nmetamethod cast(s32 _i) -> s8 (\n    ((_i -> int) % 0x80) + ((_i -> int) / 0x80000000) * 0x80 -> s8\n);\nmetamethod cast(s16 _i) -> s32 (\n    ((_i -> int) % 0x8000) + ((_i -> int) / 0x8000) * 0x80000000 -> s32\n);\nmetamethod cast(s16 _i) -> s8 (\n    ((_i -> int) % 0x80) + ((_i -> int) / 0x8000) * 0x80 -> s8\n);\nmetamethod cast(s8 _i) -> s32 (\n    ((_i -> int) % 0x8000) + ((_i -> int) / 0x80) * 0x80000000 -> s32\n);\nmetamethod cast(s8 _i) -> s16 (\n    ((_i -> int) % 0x80) + ((_i -> int) / 0x80) * 0x8000 -> s16\n);\n// Finally, u32 cast to s32 and so on, though without the sign bit\nmetamethod get_signed(u32 _i) -> s32 ((_i -> int) % 0x80000000 -> s32);\nmetamethod get_unsigned(s32 _i) -> u32 ((_i -> int) % 0x80000000 -> u32);\n\nmetamethod lt(s32 _a, s32 _b) -> int ((_a -> int)+0x80000000) < ((_b -> int)+0x80000000) ;\nmetamethod gt(s32 _a, s32 _b) -> int ((_a -> int)+0x80000000) > ((_b -> int)+0x80000000) ;\nmetamethod le(s32 _a, s32 _b) -> int ((_a -> int)+0x80000000) <= ((_b -> int)+0x80000000) ;\nmetamethod ge(s32 _a, s32 _b) -> int ((_a -> int)+0x80000000) >= ((_b -> int)+0x80000000) ;\n\nabstract class u32 {}\nabstract class u16 {}\nabstract class u8  {}\nabstract class s32 {}\nabstract class s16 {}\nabstract class s8  {}");
  GenerateReadOnly("packedpair.bc", "class packedpair<A,B> {\n    A a;\n    B b;\n    virtual function consume() -> A, B {\n        return (this.a, this.b, free(this) -> A, B);\n    }\n    \n    static function consumeAll(int length, @packedpair<void,void> elements, @void a, @void b){\n        while(length--){\n            *(a), *(b) = (*elements).consume();\n            elements++;\n            a++;\n            b++;\n        }\n    }\n    \n    new(A a, B b){\n        this.a = a;\n        this.b = b;\n    };\n}");
  GenerateReadOnly("stack.bc", "metamethod getindex<T>(Stack<T> this, int i) -> T{\n    return *(this.Data+i%this.Length);\n}\nmetamethod setindex<T>(Stack<T> this, int i, T v){\n    *(this.Data+i%this.Length) = v;\n}\nmetamethod ptrindex<T>(Stack<T> this, int i) -> @T{\n    return this.Data+i%this.Length;\n}\n\nclass Stack<T> {\n    int Capacity;\n    int Length;\n    @T Data;\n    \n    new(){\n        this.Capacity = 8;\n        this.Data = alloc(8);\n    }\n    \n    new(int cap){\n        this.Capacity = cap;\n        this.Data = alloc(cap);\n    }\n     \n    virtual function Push(T v){\n        if(this.Length == this.Capacity){\n            @T newBuff = alloc(this.Capacity * 2);\n            int i = 0;\n            while(i < this.Length){\n                *(newBuff + i) = *(this.Data + i);\n                i++;\n            }\n            this.Capacity = this.Capacity * 2;\n            @T oldData = this.Data;\n            this.Data = newBuff;\n            free(oldData);\n        };\n        *(this.Data + this.Length) = v;\n        this.Length++;\n    }\n    virtual function Pop() -> T {\n        if(this.Length){\n            this.Length--;\n            return *(this.Data + this.Length);\n        }\n        return (0 -> T);\n    }\n    virtual function Peek() -> T {\n        if(this.Length) return *(this.Data + this.Length - 1);\n        return (0 -> T);\n    }\n    virtual function Has() -> int {\n        if this.Length return 1;\n        return 0;\n    }\n}");
  GenerateReadOnly("string.bc", "abstract class string {}\nmetamethod get_length(string this) -> int *(this -> @int);\nmetamethod get_chars(string this) -> @int 1+(this -> @int);\nmetamethod getindex(string this, int index) -> int this.chars[index % this.length];\nmetamethod setindex(string this, int index, int value) -> int this.chars[index % this.length] = value;\nmetamethod ptrindex(string this, int index) -> @int &this.chars[index % this.length]");
  GenerateReadOnly("stringify.bc", "include packedpair.bc;\ninclude string.bc;\n\nmetamethod cast(packedpair<void, stringifyMethod> this) -> stringified (this -> stringified);\nmetamethod cast(stringified this) -> packedpair<void, stringifyMethod> (this -> packedpair<void, stringifyMethod>);\n\nabstract class stringifyMethod {}\nmetamethod cast(stringifyMethod this) -> func(void, func(int)) (this -> func(void, func(int)));\nmetamethod cast(func(void, func(int)) this) -> stringifyMethod (this -> stringifyMethod);\n\nabstract class stringified {\n    virtual function consume() -> void, stringifyMethod (this -> packedpair<void, stringifyMethod>).consume();\n\n    static function from(void n, stringifyMethod method) -> stringified new packedpair(n, method);\n    static function deliminated(func(int) iterator, stringified seperator, params stringified[count] elements){\n        void sep, func(void,func(int)) method = seperator.consume();\n        int i = 0;\n        while(i < count){\n            if(i){\n                method(sep, iterator);\n            }\n            void element, func(void,func(int)) elementMethod = elements[i].consume();\n            elementMethod(element, iterator);\n            i++;\n        }\n    }\n    static function join(func(int) iterator, params stringified[count] elements){\n        int i = 0;\n        while(i < count){\n            void element, func(void,func(int)) elementMethod = elements[i].consume();\n            elementMethod(element, iterator);\n            i++;\n        }\n    }\n}\n\nfunction intToString(int n, func(int) iterator){\n    if(!n){\n        iterator('0');\n        return;\n    }\n    while(n){\n        n,int m = n /% 10;\n        iterator(m+'0');\n    }\n}\nmetamethod cast(int n) -> stringified stringified.from(n, intToString);\n\nfunction iterateString(string s, func(int) iterator){\n    int i = 0;\n    int l = s.length;\n    while(i < l){\n        iterator(s[i]);\n        i++;\n    }\n}\nmetamethod cast(string s) -> stringified stringified.from(s, iterateString);");
  GenerateReadOnly("term.bc", "include stack.bc;\ninclude string.bc;\n\nmetamethod get_R(Color3B c) -> int {\n    return (c->int)%2;\n}\nmetamethod get_G(Color3B c) -> int {\n    return ((c->int)/2)%2;\n}\nmetamethod get_B(Color3B c) -> int {\n    return ((c->int)/4)%2;\n}\nabstract class Color3B {\n    static function FromRGB(int r, int g, int b) -> Color3B{\n        return ((r%2) + (g%2)*2 + (b%2)*4 -> Color3B);\n    }\n}\n\nColor3B Black   = (0 -> Color3B);\nColor3B Red     = (1 -> Color3B);\nColor3B Green   = (2 -> Color3B);\nColor3B Yellow  = (3 -> Color3B);\nColor3B Blue    = (4 -> Color3B);\nColor3B Magenta = (5 -> Color3B);\nColor3B Cyan    = (6 -> Color3B);\nColor3B White   = (7 -> Color3B);\n\n@int numBuffer = reserve 10;\nabstract class Term {    \n    static function WriteLen(int length, @int data){\n        while(length--)putchar(data++);\n    }\n\n    static function Write(string text){\n        Term.WriteLen(text.length, text.chars);\n    }\n    \n    static function WriteNum(int n){\n        if(n==0)return putchar('0');\n        int l = 0;\n        while(n>0){\n            n,int m = n/%10;\n            *((numBuffer+4)-l) = '0' + m;\n            l++;\n        }\n        Term.WriteLen(l, (numBuffer+5)-l);\n    }\n    \n    static function smethod(int c){\n        putchar(0x1B);\n        putchar('[');\n        putchar(c);\n    }\n    \n    static function method(int n, int c){\n        putchar(0x1B);\n        putchar('[');\n        Term.WriteNum(n);\n        putchar(c);\n    }\n    \n    // Formatting stuff\n    static function format(int n){\n        Term.method(n, 'm');\n    }\n    static __Style Style;\n    static __Cursor Cursor;\n    \n    // Clear\n    static function ClearAfter(){\n        return Term.smethod('J');\n    }\n    static function ClearBefore(){\n        return Term.method(1, 'J');\n    }\n    static function Clear(){\n        return Term.method(2, 'J');\n    }\n    \n    // Events\n    static function PollEvents(){\n        int r = getchar();\n        if(r){\n            int low = getchar();\n            int high = getchar();\n            int i = 0;\n            if(r == 1){\n                while(i < Term.Click.Length){\n                    (Term.Click[i++] -> func(int,int))(low, high)\n                }\n            }else if (r == 2){\n                while(i < Term.KeyDown.Length){\n                    (Term.KeyDown[i++] -> func(int,int))(low, high)\n                }\n            }else if (r == 3){\n                while(i < Term.KeyUp.Length){\n                    (Term.KeyUp[i++] -> func(int,int))(low, high)\n                }\n            }else if (r == 4){\n                while(i < Term.Frame.Length){\n                    (Term.Frame[i++] -> func())()\n                }\n            }\n        }\n    }\n    \n    \n    \n    static Stack<func(int,int)> KeyDown = reserve Stack(1);\n    static Stack<func(int,int)> KeyUp = reserve Stack(1);\n    static Stack<func(int,int)> Click = reserve Stack(1);\n    static Stack<func()> Frame = reserve Stack(1);\n}\n\nmetamethod get_Fore(__Style s) -> void{return 0;}\nmetamethod get_Back(__Style s) -> void{return 0;}\nmetamethod get_Bold(__Style s) -> void{return 0;}\nmetamethod get_Italic(__Style s) -> void{return 0;}\nmetamethod get_Underline(__Style s) -> void{return 0;}\nmetamethod get_Striked(__Style s) -> void{return 0;}\n\nmetamethod set_Fore(__Style s, Color3B col){\n    return Term.format(30 + (col -> int));\n}\nmetamethod set_Back(__Style s, Color3B col){\n    return Term.format(40 + (col -> int));\n}\nmetamethod set_Bold(__Style s, int b){\n    if(b)Term.format(1)\n    else Term.format(22);\n}\nmetamethod set_Italic(__Style s, int b){\n    if(b)Term.format(3)\n    else Term.format(23);\n}\nmetamethod set_Underline(__Style s, int b){\n    if(b)Term.format(4)\n    else Term.format(24);\n}\nmetamethod set_Striked(__Style s, int b){\n    if(b)Term.format(9)\n    else Term.format(29);\n}\nabstract class __Style {\n}\n\nmetamethod get_X(__Cursor c) -> void {return 0};\nmetamethod get_Y(__Cursor c) -> void {return 0};\nmetamethod get_Up(__Cursor c) -> void {return 0};\nmetamethod get_Down(__Cursor c) -> void {return 0};\nmetamethod get_Left(__Cursor c) -> void {return 0};\nmetamethod get_Right(__Cursor c) -> void {return 0};\n\nmetamethod set_X(__Cursor c, int x){ return Term.method(x, 'G') }\nmetamethod set_Y(__Cursor c, int y){ return Term.method(y, 'H') }\nabstract class __Cursor {\n    virtual function Up(int n){ return Term.method(n, 'A') }\n    virtual function Down(int n){ return Term.method(n, 'B') }\n    virtual function Left(int n){ return Term.method(n, 'D') }\n    virtual function Right(int n){ return Term.method(n, 'C') }\n    virtual function Push(){ return Term.smethod('s') }\n    virtual function Pop(){ return Term.smethod('u') }\n    virtual function Reset(){ return Term.smethod('H') }\n    virtual function NextLine(){ return Term.method(1, 'E') }\n    virtual function PrevLine(){ return Term.method(1, 'F') }\n}");
  GenerateReadOnly("*", Object.keys(AllReadOnlys).map(c => `include ${c};`).join('\n'));
}
